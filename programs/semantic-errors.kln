(* Unused function should have warning *)
function unused_fun(unused_arg: integer): integer (* unused arg should have warning *)
    1

(* Duplicated function name should raise an error *)
function duplicated_fun_name(): integer
    1

function duplicated_fun_name(): integer
    2

(* Function with duplicated argument name should raise an error *)
function duplicated_arg_name(a: integer, a: integer): integer
    1

(* Used defined print function should raise an error *)
(* Our parser does not even allow a function with the name print to exist
So, we cannot test this at this stage.
function print(a: integer): integer
    1 *)

(* Expression being called with wrong typed children should raise an error *)
function expression_called_with_wrong_children(): boolean
    print(true + true)
    print(1 + true)
    print(true - false)
    print(1 - false)
    print(false * true)
    print(1 * true)
    print(false / false)
    print(1 / false)
    print(true < true)
    print(1 < true)
    print(not 1)
    print(2 and 3)
    print(true and 3)
    print(4 or 5)
    print(false or 5)
    true

(* If being called with an integer in place of conditional should raise error *)
function if_called_with_int_as_conditional(): integer
    if 1 then 2 else 3

(* If having 2 different values inside of print should *not* raise an error *)
function union_print_type(): integer
    print(if true then 1 else false)
    print(if true then false else 1)
    1

(* If possibly returning the wrong type should raise error *)
function if_possible_wrong_return_type_return(): integer
    if true then 1 else false

(* Function which claims to return int and returns bool should raise error *)
function returns_wrong_type_int(): integer
    true

(* Function which claims to return bool and returns int should raise error *)
function returns_wrong_type_bool(): boolean
    1

function i_return_int(): integer
    1

(* Returning a function which return wrong type should raise error *)
function return_wrong_type(): boolean
    i_return_int()

(* Calling a nonexistant funtion should raise error *)
function calls_nonexistant_fun(): integer
    print(nonexistant_fun())
    1

(* Using param as function should raise error *)
function calls_param_as_fun(int_param: integer): integer
    int_param()

(* Using a nonexistant parameter should raise error *)
function uses_nonexistant_param(): integer
    1 + nonexistant_param

(* Using a function as an identifier should raise error *)
function uses_function_as_identififer(): integer
    1 + uses_function_as_identififer

(* Addition error should bubble-up cleanly with 1 error at root and 1 at return value *)
function error_bubbles_cleanly(): integer
    false + 2 + 3 + 4 + 5

(* Having the wrong type of parameter or the wrong amount should raise an error *)
function Param_call(): integer
    print(int_typing(true))
    print(bool_typing(1))
    print(sequential_typing(1, 2, false))
    print(too_many_param(1,2))
    print(too_few_param(1,2))
    1
function bool_typing(wrong_type: boolean): boolean
    wrong_type
function int_typing(wrong_type:integer): integer
    wrong_type
function sequential_typing(a: integer, b: boolean, c: boolean): integer
    if b and c then a else 1
function too_many_param(a: integer): integer
    a
function too_few_param(a: integer, b: integer, c: integer): integer
    a + b + c

(* Recursive function should *not* raise error *)
function recursive_fun(a: integer): integer
    if a < 1
    then a
    else a + recursive_fun(a - 1)
    
(* Missing a main function should raise an error *)